##### See also
- https://stackoverflow.com/questions/5081875/ctypes-beginner
- https://stackoverflow.com/questions/24640817/python-ctypes-definition-for-c-struct
- https://stackoverflow.com/questions/62277376/python-ctypes-pointer-to-struct-as-identifier-without-member-access
- https://tristan-ka.github.io/IBOAT_RL/_downloads/SIMULINK_TO_C__PYTHON.pdf


# Matlab/Simulink coder -> C/C++ -> Python bindings examples

This folder shows examples for the process of generating embeddable ```C/C++``` code from a Matlab/Simulink model and then importing the code into a Python runtime environment.

- This has runtime speed advantages over calling the Matlab Engine directly in Python, as well as allows for deploying the codes to environments that do not contain a Matlab license

This is accomplished by compiling the ```C/C++``` code into a *shared library* - which is a dynamically loaded library that hosts the compiled ```C/C++``` code and exposes methods for use by marking them as *exports*

- Depending on target platform architecture the shared library may not be suitable to be shared from another PC (unless it shares the same OS version). So, an example on compiling the autogen ```C/C++``` code is also provided

The Python standard library ```ctypes``` is used here to call compiled ```C``` functions

- ```ctypes``` is chosen because it is a standard library, so it is the most likely to be well-supported on all platforms and suffer the least from potential versioning issues
- ```Boost.Python``` also provides support for C code implementation in Python

### C/C++ Background Context

Note that any ```C++``` code (or code compiled using a C++ compiler!) that needs to be linked from another environment needs to first be treated as ```C``` code. The below indicates that ```function1``` and ```function2``` should be linked as ```C``` codes (avoids function name-mangling in the compiler more specifically)
> extern "C" {
    void function1(int* para){...}
    void function2(double* para){...}
}

Specifically in ```C++``` on Windows, all functions to be exposed in a shared library additionally need the ```_declspec(dllexport)``` imperative to be marked as a exportable and called in another environment:
> extern "C" {
_declspec(dllexport) void function1(int* para){...}
> _declspec(dllexport) void function2(double* para){...}
}

If ```ctypes``` results in an error that a function cannot be found, 1. double-check the function-call spelling, then 2. this step was probably messed up!

### Python ```ctypes``` Library for C Bindings

Python ```ctypes``` is used to load a *shared library* runtime object - which is a dynamically loaded library that hosts the compiled ```C/C++``` code
> from ctypes import *

First, load the shared library
> lib = cdll.LoadLibrary(file)

The methods exposed from the API of the shared library can be found in the ```lib``` object

# Examples 
Two wrapper files ```_cwrapper.py``` and ```_cppwrapper.py``` are provided that implement example classes for autogen code from both a matlab function and a matlab class, respectively.

#### Example 1 with C++ Class - PCC MPC

- The following is the corresponding ```C++``` wrapper code that was compiled into the shared library, where ```longitudinal_mpc0``` is the source class autogenerated from Simulink

- ```pccmpc_api.h``` and ```pccmpc_api.cpp``` are custom ```C++``` files written to expose an API from the Matlab/Simulink model's autogen code

- The following ```ctypes``` description then specifically follows the ```_cppwrapper.py``` implementation

```
/* pccmpc_api.h */
// Typedefs of the name of the autogen model for convenience - Change these based on Simulink Model name
typedef longitudinal_mpc0 AUTOGENCLASS;
typedef ExtU_longitudinal_mpc0_T AUTOGENINPUT;
typedef ExtY_longitudinal_mpc0_T AUTOGENOUTPUT;

// External API bindings
#if defined(_WIN32) || defined(__LCC__) // Windows needs to also have a dllexport or dllimport declaration
#define DLL_PORTING __declspec(dllexport)
#else
#define DLL_PORTING
#endif

extern "C" {
    // Object constructors
    DLL_PORTING AUTOGENCLASS* new_controller();
    DLL_PORTING AUTOGENINPUT* new_inputs();
    DLL_PORTING AUTOGENOUTPUT* new_outputs();

    // Object methods
    DLL_PORTING void init_controller(AUTOGENCLASS* controller);

    DLL_PORTING void set_inputs(AUTOGENCLASS* controller, AUTOGENINPUT* inputs);
    DLL_PORTING void step_controller(AUTOGENCLASS* controller);
    DLL_PORTING void get_outputs(AUTOGENCLASS* controller, AUTOGENOUTPUT* outputs);
    
    // Object destructors
    DLL_PORTING void cleanup_controller(AUTOGENCLASS* controller);
    DLL_PORTING void cleanup_inputs(AUTOGENCLASS* inputs);
    DLL_PORTING void cleanup_outputs(AUTOGENCLASS* outputs);
}
```

###### Compiling the shared library with CMake
The ```C++``` code as generated from Matlab/Simulink Coder is contained within the ```pcc_codegen\``` folder and can be compiled into a shared library with the accompanying wrapper ```pccmpc_api.cpp``` using CMake

Enter the top-level ```pcc_codegen\``` folder
> cd pcc_codegen

Refresh the ```build\``` folder in-case there are any old files leftover in it
> rm -r ./build
> mkdir ./build

Run cmake 
> cmake -B ./build -DCMAKE_BUILD_TYPE=Release
> cmake --build ./build --config Release
> cmake --install ./build --config Release

This will place generated ```.dll``` or ```.so``` files into the ```lib\``` folder that need to then be loaded by ```ctypes``` in Python

###### The ```ctypes``` wrapper code

Then, for code sanitation purposes we indicate to ```ctypes``` what the *result type* and *argument types* are for each of the external functions in the library - this will allow ```ctypes``` to then check that these types are passed to and from the functions correctly

> lib.new_controller.restype = controller
> lib.new_inputs.restype = POINTER(inputs)
> lib.new_outputs.restype = POINTER(outputs)

> lib.set_inputs.argtypes = [controller, POINTER(inputs)]
> lib.step_controller.argtypes = [controller]
> lib.get_outputs.argtypes = [controller, POINTER(outputs)]

Here, ```controller, inputs, outputs``` are custom ```ctypes``` classes that are defined to match the custom ```C++ structs``` exposed in the shared library

```
class controller(c_void_p):
    # subclassing c_void_p creates an opaque pointer type that is distinct
    # from c_void_p, and can only be instantiated as a pointer
    # We do not care to provide hints on the controller struct fields
    pass

class inputs(Structure):
    ### From the <model_name>.h autogen file
    # /* External inputs (root inport signals with default storage) */
    # struct ExtU_longitudinal_mpc0_T {
    #     real_T t;                            /* '<Root>/t' */
    #     real_T ego_state[3];                 /* '<Root>/ego_state' */
    #     real_T pv_state[3];                  /* '<Root>/pv_state' */
    #     real_T pos_max;                      /* '<Root>/pos_max' */
    #     real_T vel_max;                      /* '<Root>/vel_max' */
    # };
    '''Create a ctypes struct to match ExtU_<model_name>_T'''
    _fields_ = [
        ('t', c_double),
        ('ego_state', c_double * 3),
        ('pv_state', c_double * 3),
        ('pos_max', c_double),
        ('vel_max', c_double)
    ]

class outputs(Structure):
    ### From the longitudinal_mpc0.h autogen file
    # /* External outputs (root outports fed by signals with default storage) */
    # struct ExtY_longitudinal_mpc0_T {
    #     real_T acc_des;                      /* '<Root>/acc_des' */
    #     real_T state_trajectory[96];         /* '<Root>/state_trajectory' */
    #     real_T control_trajectory[32];       /* '<Root>/control_trajectory' */
    #     real_T slacks[4];                    /* '<Root>/slacks' */
    #     real_T reference[3];                 /* '<Root>/reference' */
    #     real_T constraint;                   /* '<Root>/constraint' */
    #     real_T cost;                         /* '<Root>/cost' */
    #     flags exitflag;                      /* '<Root>/exitflag' */
    # };

    '''Create a ctypes struct to match ExtY_<model_name>_T'''
    _fields_ = [
        ('acc_des', c_double),
        ('state_trajectory', c_double * 96),
        ('control_trajectory', c_double * 32),
        ('slacks', c_double * 4),
        ('reference', c_double * 3),
        ('constraint', c_double),
        ('cost', c_double),
        ('exitflag', c_int) # flags is a custom enum structure - will just cast to an int "unsafely"
    ]
```

Here, the controller is a complicated enough ```C++ struct``` that we do not care to fill in the fields on the ```ctypes``` side (and are not intended to directly access them anyway, unlike the inputs and outputs) - so a void pointer instead is used to empty assign the type

The ```ctypes POINTER()``` method creates a pointer to the variable as to match the expected inputs for the ```C++``` methods in the shared library. If a pointer needs to be obtained for a variable that has already been initialized by object, the ```ctypes byref()``` function generates a reference address.

The ```C++``` shared library API provides methods to allocate memory for its custom structs, so call the methods in ```ctypes``` and assign their outputs (which are pointers in this example)

```
    # Create object pointer for controller
    controller_p = lib.new_controller()
    
    # Create object pointers for inputs and outputs - since we want to work with the struct data indicate to ctypes the fields
    inputs_p = lib.new_inputs()
    outputs_p = lib.new_outputs()

    ### Initialize
    lib.init_controller(controller_p)
```

Then we need to pack the input arguments to the controller functions. Access the ctypes pointer variable using the ```.contents``` method

```
    # Assign inputs struct properties
    inputs_p.contents.t = 0 # Dereference pointer with .contents method

    inputs_p.contents.ego_state[0] = self.s
    inputs_p.contents.ego_state[1] = self.v
    inputs_p.contents.ego_state[2] = self.a

    pv_ds, pv_v, pv_ind = getFrontVeh(svs, self.x, self.y, self.len, self.theta, self.lane)

    if pv_ind >= 0:
        inputs_p.contents.pv_state[0] = pv_ds
        inputs_p.contents.pv_state[1] = svs[pv_ind].v
        inputs_p.contents.pv_state[2] = svs[pv_ind].a
    else:
        inputs_p.contents.pv_state[0] = pv_ds
        inputs_p.contents.pv_state[1] = 0
        inputs_p.contents.pv_state[2] = 0

    inputs_p.contents.pos_max = 500
    inputs_p.contents.vel_max = 35
```

Run the controller
```
    # Run the autogen controller
    lib.set_inputs(controller_p, inputs_p)
    lib.step_controller(controller_p)
    lib.get_outputs(output_p)
```

Then dereference the outputs into python variables
```
    # Assign outputs from struct properties
    acc_des = outputs_p.contents.acc_des
```

When closing the program, the ```C++``` shared library api offers cleanup routines to de-allocate memory and perform sanitation
```
    lib.cleanup_controller(controller_p)
    lib.cleanup_inputs(inputs_p)
    lib.cleanup_outputs(outputs_p)
```

#### Example 2 with C Function - CAV Control Model

- See also https://blogs.mathworks.com/simulink/2022/12/23/leveraging-generated-code-from-matlab-in-a-c-application/

The following Matlab function is desired to be compiled into a shared library to be called in Python
>function [aRef, vRef, sRef] = CAV_ctrl_mdl(IntscInfo, SpdLimInfo, CtrlInfo, CtrlPar, StopInfo)

###### Compiling the shared library with CMake

- The following is the Matlab script to generate the build files to compile a Matlab function ```CAV_ctrl_mdl```

```
default_folder_path = pwd; 
CAVmdl_folder_path = [default_folder_path,'\mdlCAV'];
cd(CAVmdl_folder_path)

% CAV mdl example
IntscInfo = zeros(6,5);
SpdLimInfo = zeros(2,2);
CtrlInfo = zeros(1,14);
CtrlPar = zeros(1,15);
StopInfo = zeros(1,2);

% generate build files for a dynamic C/C++ library (.dll) with a package
cfg = coder.config('dll');
cfg.TargetLang = 'C++'; % Libraries in Python need C bindings - extern _declspec(dllexport)
cfg.Verbosity = 'Verbose';
cfg.GenCodeOnly = true; % True or false - if True use CMake on target hardware to generate the DLL/SO

codegen -config cfg CAV_ctrl_mdl -args {IntscInfo, SpdLimInfo, CtrlInfo, CtrlPar, StopInfo}

codebuild('./codegen/dll/CAV_ctrl_mdl', 'BuildMethod', 'CMake', 'BuildVariant', 'SHARED_LIBRARY'); % BuildMethod CMake creates a CMakeLists.txt
packNGo('./codegen/dll/CAV_ctrl_mdl');
```

Unlike the ```C++``` class example, this example directly exports a single function, ```CAV_ctrl_mdl```, that generates control signals from input arguments ```IntscInfo, SpdLimInfo, CtrlInfo, CtrlPar, StopInfo```

###### The ```C``` Code
The interface in ```C``` is found in the newly-generated CAV_ctrl_mdl.h and can be seen as
```
    #ifdef __cplusplus
    extern "C" {
    #endif

    /* Function Declarations */
    CAV_CTRL_MDL_DLL_EXPORT extern void CAV_ctrl_mdl(const double IntscInfo[30],
                            const double SpdLimInfo[4],
                            const double CtrlInfo[14],
                            const double CtrlPar[15],
                            const double StopInfo[2], double *aRef,
                            double *vRef, double *sRef);

    #ifdef __cplusplus
    }
    #endif
```

Notably, the original Matlab function had multiple output arguments: ```aRef, vRef, sRef```. The ```C/C++``` ecosystem handles this by passing input pointer variables ```*aRef, *vRef, *sRef``` - which values are directly changed through the function call.

The shared library then is compiled using CMake

```
    C:\path\to\CAV_ctrl_mdl> mkdir build
    C:\path\to\CAV_ctrl_mdl> cmake -B ./build -DCMAKE_BUILD_TYPE=Release
    C:\path\to\CAV_ctrl_mdl> cmake --build build --config Release
    C:\path\to\CAV_ctrl_mdl> cmake --install build --config Release
```

###### The ```ctypes``` Python wrapper code

- The following is pulled from the ```_cwrapper.py``` class definition file

Utilize the ```ctypes``` Python library to load the *shared library* runtime object
> from ctypes import *

First, load the shared library
> lib = cdll.LoadLibrary(file)


As before, for code sanitation purposes we indicate to ```ctypes``` what the *result type* and *argument types* are for each of the external functions in the library - this will allow ```ctypes``` to then check that these types are passed to and from the functions correctly

```
    lib.CAV_ctrl_mdl.argtypes = [
        POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_double), 
        POINTER(c_double), POINTER(c_double), POINTER(c_double)
    ]
    lib.CAV_ctrl_mdl.restype = None # void in C/C++ means None, void pointer is a pointer that points to nothing
```


And similar to before, run the built-in method to initialize the autogen model
```
    # Runs the initialization routine for the model
    lib.CAV_ctrl_mdl_initialize()
```

The ```CAV_ctrl_mdl``` function expects *arrays of doubles*. In ```C``` an array is passed to a function as a pointer that points to the beginning of the array. As such, this address **has** to have the correct amount of contiguously-allocated bytes following it that correspond to the rest of the array

In ```ctypes``` we can call the ```CAV_ctrl_mdl``` method by first generating c-style arrays from Python vectors, as well as verifying their size is the same as what the ```C``` library expects. Here the ```ctypes.byref``` method is used to pass the ```c_double``` variables ```aRef, vRef, sRef``` by reference (reference is a ```c``` type for a pointer address)

```
def step(IntscInfo, SpdLimInfo, CtrlInfo, CtrlPar, StopInfo):
    # C Function syntax was:
    # void CAV_ctrl_mdl(const double IntscInfo[30],
    #                        const double SpdLimInfo[4],
    #                        const double CtrlInfo[14],
    #                        const double CtrlPar[15],
    #                        const double StopInfo[2], double *aRef,
    #                        double *vRef, double *sRef)

    def assert_len(v, l):
        len_v = len(v)
        assert len_v == l, 'Python input array mis-sized! Was expecting len={:d} but got {:d}'.format(l, len_v)

    def make_c_array(v, l):
        # Check size of input vector
        assert_len(v, l)

        # Make c array
        c_array = (c_double * l)()
        
        for i in range(0, l):
            c_array[i] = v[i]

        return c_array
    
    ### Generate c arrays from inputs and check size
    c_IntscInfo = make_c_array(IntscInfo, 30)
    c_SpdLimInfo = make_c_array(SpdLimInfo, 4)
    c_CtrlInfo = make_c_array(CtrlInfo, 14)
    c_CtrlPar = make_c_array(CtrlPar, 15)
    c_StopInfo = make_c_array(StopInfo, 2)

    # Make variables that will get the outputs from c library method
    aRef = c_double() # Will pass these by reference (pointer)
    vRef = c_double()
    sRef = c_double()

    ### Step the control model - the output arguments are stored in the pointers aRef, vRef...
    lib.CAV_ctrl_mdl(
        c_IntscInfo, c_SpdLimInfo, c_CtrlInfo, c_CtrlPar, c_StopInfo,
        byref(aRef), byref(vRef), byref(sRef)
    )

    # Outputs
    return aRef.value, vRef.value, sRef.value
```

When done with the shared library we call the built-in method to terminate the autogen model
```
    # Frees memory allocated by control model shared object and terminates model dependencies
    lib.CAV_ctrl_mdl_terminate()
```